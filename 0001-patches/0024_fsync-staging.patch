From f443c77975c10da4298906854e31e2ade12bd373 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 8 Aug 2019 17:12:46 -0500
Subject: ntdll/fsync: Fix a race condition when waiting on a mutex.


diff --git a/dlls/ntdll/fsync.c b/dlls/ntdll/fsync.c
index 41ea07ae00b..9f1d6895c25 100644
--- a/dlls/ntdll/fsync.c
+++ b/dlls/ntdll/fsync.c
@@ -862,6 +862,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                     case FSYNC_MUTEX:
                     {
                         struct mutex *mutex = obj->shm;
+                        int tid;
 
                         if (mutex->tid == GetCurrentThreadId())
                         {
@@ -870,7 +871,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             return i;
                         }
 
-                        if (!__sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() ))
+                        if (!(tid = __sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() )))
                         {
                             TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                             mutex->count = 1;
@@ -878,7 +879,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         }
 
                         futexes[i].addr = &mutex->tid;
-                        futexes[i].val  = mutex->tid;
+                        futexes[i].val  = tid;
                         break;
                     }
                     case FSYNC_AUTO_EVENT:
