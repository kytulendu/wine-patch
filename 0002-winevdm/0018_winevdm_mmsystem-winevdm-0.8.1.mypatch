From 2673a6365264bb15a95ab2fab680b2a6a09aa68a Mon Sep 17 00:00:00 2001
From: Khralkatorrix <garuda2550@gmail.com>
Date: Sat, 4 Feb 2023 15:23:05 +0700
Subject: [PATCH 18/23] mmsystem.dll16: Update to winevdm-0.8.1.

---
 dlls/mmsystem.dll16/driver.c    |  18 ++-
 dlls/mmsystem.dll16/mci16.c     | 230 +++++++++++++++++++++++++++++---
 dlls/mmsystem.dll16/message16.c | 124 +++++++++--------
 dlls/mmsystem.dll16/mmio16.c    | 140 ++++++++++++-------
 dlls/mmsystem.dll16/mmsystem.c  |  89 +++++++++---
 dlls/mmsystem.dll16/mmsystem.dll16.spec | 2 ++
 6 files changed, 459 insertions(+), 144 deletions(-)

diff --git a/dlls/mmsystem.dll16/driver.c b/dlls/mmsystem.dll16/driver.c
index b26dbb796d9..37059ed863f 100644
--- a/dlls/mmsystem.dll16/driver.c
+++ b/dlls/mmsystem.dll16/driver.c
@@ -268,9 +268,21 @@ HDRVR16 WINAPI DrvOpen16(LPCSTR lpDriverName, LPCSTR lpSectionName, LPARAM lPara
 				 drvName, sizeof(drvName), "SYSTEM.INI") > 0) {
 	lpDrv = DRIVER_TryOpenDriver16(drvName, lParam2);
     }
-    if (!lpDrv) {
-	TRACE("Failed to open driver %s from system.ini file, section %s\n", debugstr_a(lpDriverName), debugstr_a(lpSectionName));
-	return 0;
+    if (!lpDrv)
+    {
+        if (!stricmp(lpSectionName, "drivers"))
+        {
+            // if 32bit driver exists pretend success
+            if (GetPrivateProfileStringA("drivers32", lpDriverName, "",
+                                        drvName, sizeof(drvName), "SYSTEM.INI") > 0)
+                return 0xdead;
+        }
+        else if (!stricmp(lpSectionName, "mci"))
+        {
+            if (GetPrivateProfileStringA("mci32", lpDriverName, "",
+                                        drvName, sizeof(drvName), "SYSTEM.INI") > 0)
+                return 0xdead;
+        }
     }
  the_end:
     TRACE("=> %04x / %p\n", lpDrv->hDriver16, lpDrv);
diff --git a/dlls/mmsystem.dll16/mci16.c b/dlls/mmsystem.dll16/mci16.c
index 9015f5509b9..035705330bb 100644
--- a/dlls/mmsystem.dll16/mci16.c
+++ b/dlls/mmsystem.dll16/mci16.c
@@ -22,6 +22,7 @@
 #include <stdarg.h>
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -33,11 +34,88 @@
 #include "wine/winuser16.h"
 #include "winemm16.h"
 #include "digitalv.h"
+#include "mciavi.h"
 
 #include "wine/debug.h"
 
+#ifndef MCI_OPEN_DRIVER
+#define MCI_OPEN_DRIVER 0x0801
+#endif
+#ifndef MCI_CLOSE_DRIVER
+#define MCI_CLOSE_DRIVER 0x0802
+#endif
+
 WINE_DEFAULT_DEBUG_CHANNEL(mmsys);
 
+char *WINAPI xlate_str_handle(const char *origstr, char *newstr)
+{
+    int pos0, pos1, pos2;
+    int count;
+
+    if (!strncmp(origstr, "update ", 7))
+    {
+        int hdc16;
+        count = sscanf(origstr, "%[a-z ]%n%d%n", newstr, &pos1, &hdc16, &pos2);
+        sprintf(newstr + pos1, " %u%s", HDC_32((HDC16)hdc16), origstr + pos2);
+        return newstr;
+    }
+    else if (!strncmp(origstr, "setvideo ", 9))
+    {
+        char *pal = strstr(origstr, "palette handle");
+        if (pal)
+        {
+            int hpal16;
+            pos0 = (intptr_t)pal - (intptr_t)origstr;
+            memcpy(newstr, origstr, pos0);
+            count = sscanf(pal, "%[a-z ]%n%d%n", newstr + pos0, &pos1, &hpal16, &pos2);
+            sprintf(newstr + pos0 + pos1, " %u%s", HPALETTE_32((HPALETTE16)hpal16), pal + pos2);
+            return newstr;
+        }
+    }
+    else if (!strncmp(origstr, "open ", 5))
+    {
+        char *par = strstr(origstr, "parent");
+        if (par)
+        {
+            int hwnd16;
+            pos0 = (intptr_t)par - (intptr_t)origstr;
+            memcpy(newstr, origstr, pos0);
+            count = sscanf(par, "%[a-z ]%n%d%n", newstr + pos0, &pos1, &hwnd16, &pos2);
+            sprintf(newstr + pos0 + pos1, " %u%s", HWND_32((HWND16)hwnd16), par + pos2);
+            return newstr;
+        }
+    }
+    else if (!strncmp(origstr, "window ", 7))
+    {
+        char *hand = strstr(origstr, "handle");
+        if (hand)
+        {
+            int hwnd16;
+            pos0 = (intptr_t)hand - (intptr_t)origstr;
+            memcpy(newstr, origstr, pos0);
+            count = sscanf(hand, "%[a-z ]%n%d%n", newstr + pos0, &pos1, &hwnd16, &pos2);
+            sprintf(newstr + pos0 + pos1, " %u%s", HWND_32((HWND16)hwnd16), hand + pos2);
+            return newstr;
+        }
+    }
+
+    return origstr;
+}
+
+static void xlate_stat_handle(const char *cmdstr, char *retstr)
+{
+    if (strstr(cmdstr, "window handle"))
+    {
+        DWORD handle = strtoul(retstr, NULL, 10);
+        itoa(HWND_16(handle), retstr, 10);
+    }
+    else if (strstr(cmdstr, "palette handle"))
+    {
+        DWORD handle = strtoul(retstr, NULL, 10);
+        itoa(HPALETTE_16(handle), retstr, 10);
+    }
+}
+
 /**************************************************************************
  * 			MCI_MessageToString			[internal]
  */
@@ -132,7 +210,14 @@ static LPWSTR MCI_strdupAtoW( LPCSTR str )
 static MMSYSTEM_MapType	MCI_MapMsg16To32W(WORD wMsg, DWORD dwFlags, DWORD_PTR* lParam)
 {
     if (*lParam == 0)
-	return MMSYSTEM_MAP_OK;
+    {
+        if (wMsg == MCI_PLAY)
+        {
+            *lParam = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MCI_GENERIC_PARMS));
+            return MMSYSTEM_MAP_OKMEM;
+        }
+        return MMSYSTEM_MAP_OK;
+    }
     /* FIXME: to add also (with seg/linear modifications to do):
      * MCI_LOAD, MCI_QUALITY, MCI_RESERVE, MCI_RESTORE, MCI_SAVE, MCI_SETTUNER
      */
@@ -159,16 +244,88 @@ static MMSYSTEM_MapType	MCI_MapMsg16To32W(WORD wMsg, DWORD dwFlags, DWORD_PTR* l
     case MCI_SEEK:
     case MCI_SET:
     case MCI_SETAUDIO:
-    case MCI_SETVIDEO:
 	/* case MCI_SETTIMECODE:*/
-	/* case MCI_SIGNAL:*/
+    case MCI_SIGNAL:
     case MCI_SPIN:
     case MCI_STEP:
     case MCI_STOP:
 	/* case MCI_UNDO: */
+        {
+            LPMCI_GENERIC_PARMS mgp = MapSL(*lParam);
+            mgp->dwCallback = HWND_32(mgp->dwCallback);
+            *lParam = mgp;
+        }
+        return MMSYSTEM_MAP_OKMEM;
+    case MCI_SETVIDEO:
+        {
+            LPMCI_DGV_SETVIDEO_PARMSA mdsvp32 =  HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                sizeof(LPMCI_DGV_SETVIDEO_PARMS16) + sizeof(MCI_DGV_SETVIDEO_PARMSA));
+            LPMCI_DGV_SETVIDEO_PARMS16 mdsvp16 = MapSL(*lParam);
+            if (mdsvp32)
+            {
+                *(LPMCI_DGV_SETVIDEO_PARMS16*)(mdsvp32) = mdsvp16;
+                mdsvp32 = (LPMCI_DGV_SETVIDEO_PARMSA)((char*)mdsvp32 + sizeof(LPMCI_DGV_SETVIDEO_PARMS16));
+                mdsvp32->dwCallback = HWND_32(mdsvp16->dwCallback);
+                mdsvp32->dwItem = mdsvp16->dwItem;
+                if ((dwFlags & MCI_DGV_SETVIDEO_ITEM) && (mdsvp16->dwItem == MCI_DGV_SETVIDEO_PALHANDLE))
+                    mdsvp32->dwValue = HPALETTE_32(mdsvp16->dwValue);
+                else if ((dwFlags & MCI_DGV_SETVIDEO_ITEM) && (mdsvp16->dwItem == MCI_AVI_SETVIDEO_DRAW_PROCEDURE))
+                {
+                    static void *(*get_video_thunk)(DWORD) = 0;
+                    if (!get_video_thunk)
+                    {
+                        HMODULE msvideo = LoadLibraryA("msvideo.dll16");
+                        if (msvideo)
+                            get_video_thunk = (void *(*)(DWORD))GetProcAddress(msvideo, "get_video_thunk");
+                    }
+                    if (get_video_thunk)
+                        mdsvp32->dwValue = get_video_thunk(mdsvp16->dwValue);
+                }
+                else
+                {
+                    mdsvp32->dwValue = mdsvp16->dwValue;
+                }
+
+                mdsvp32->dwOver = mdsvp16->dwOver;
+                if (dwFlags & MCI_DGV_SETVIDEO_ALG)
+                    mdsvp32->lpstrAlgorithm = MapSL(mdsvp16->lpstrAlgorithm);
+                if (dwFlags & MCI_DGV_SETVIDEO_QUALITY)
+                    mdsvp32->lpstrQuality = MapSL(mdsvp16->lpstrQuality);
+                *lParam = (DWORD)mdsvp32;
+            } else {
+                return MMSYSTEM_MAP_NOMEM;
+            }
+        }
+        return MMSYSTEM_MAP_OKMEM;
     case MCI_UPDATE:
-        *lParam = (DWORD)MapSL(*lParam);
-        return MMSYSTEM_MAP_OK;
+        {
+            if (dwFlags & (MCI_DGV_UPDATE_HDC | MCI_DGV_RECT))
+            {
+                LPMCI_DGV_UPDATE_PARMS mdup32 = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(LPMCI_DGV_UPDATE_PARMS16) + sizeof(MCI_DGV_UPDATE_PARMS));
+                LPMCI_DGV_UPDATE_PARMS16 mdup16 = MapSL(*lParam);
+                if (mdup32) {
+                    *(LPMCI_DGV_UPDATE_PARMS16*)(mdup32) = mdup16;
+                    mdup32 = (LPMCI_DGV_UPDATE_PARMS)((char*)mdup32 + sizeof(LPMCI_DGV_UPDATE_PARMS16));
+                    mdup32->dwCallback = HWND_32(mdup16->dwCallback);
+                    mdup32->rc.left = mdup16->rc.left;
+                    mdup32->rc.top = mdup16->rc.top;
+                    mdup32->rc.right = mdup16->rc.right;
+                    mdup32->rc.bottom = mdup16->rc.bottom;
+                    mdup32->hDC = HDC_32(mdup16->hDC);
+                    *lParam = (DWORD)mdup32;
+                } else {
+                    return MMSYSTEM_MAP_NOMEM;
+                }
+            }
+            else
+            {
+                LPMCI_GENERIC_PARMS mgp = MapSL(*lParam);
+                mgp->dwCallback = HWND_32(mgp->dwCallback);
+                *lParam = mgp;
+            }
+        }
+        return MMSYSTEM_MAP_OKMEM;
     case MCI_WHERE:
     case MCI_FREEZE:
     case MCI_UNFREEZE:
@@ -214,7 +371,8 @@ static MMSYSTEM_MapType	MCI_MapMsg16To32W(WORD wMsg, DWORD dwFlags, DWORD_PTR* l
                 }
             } else {
                 *lParam = (DWORD)MapSL(*lParam);
-                return MMSYSTEM_MAP_OK;
+                if(!(dwFlags & MCI_STATUS_ITEM))
+                    return MMSYSTEM_MAP_OK;
             }
         }
         return MMSYSTEM_MAP_OKMEM;
@@ -411,12 +569,31 @@ static  void	MCI_UnMapMsg16To32W(WORD wMsg, DWORD dwFlags, DWORD_PTR lParam, DWO
     case MCI_SEEK:
     case MCI_SET:
     case MCI_SETAUDIO:
-    case MCI_SETVIDEO:
     case MCI_SPIN:
     case MCI_STEP:
     case MCI_STOP:
+    case MCI_SIGNAL:
+        if (lParam)
+        {
+            LPMCI_GENERIC_PARMS mgp = (LPMCI_GENERIC_PARMS)lParam;
+            mgp->dwCallback = HWND_16(mgp->dwCallback);
+        }
+        break;
+    case MCI_SETVIDEO:
+        if (lParam)
+        {
+            char *base = (char*)lParam - sizeof(LPMCI_DGV_SETVIDEO_PARMS16);
+            HeapFree(GetProcessHeap(), 0, base);
+        }
+        break;
     case MCI_UPDATE:
-        if (lParam) {
+        if (dwFlags & (MCI_DGV_UPDATE_HDC | MCI_DGV_RECT))
+        {
+            char *base = (char*)lParam - sizeof(LPMCI_DGV_UPDATE_PARMS16);
+            HeapFree(GetProcessHeap(), 0, base);
+        }
+        else if (lParam)
+        {
             LPMCI_GENERIC_PARMS mgp = (LPMCI_GENERIC_PARMS)lParam;
             mgp->dwCallback = HWND_16(mgp->dwCallback);
         }
@@ -437,13 +614,23 @@ static  void	MCI_UnMapMsg16To32W(WORD wMsg, DWORD dwFlags, DWORD_PTR lParam, DWO
         }
         break;
     case MCI_STATUS:
-        if (lParam) {
-            LPMCI_DGV_STATUS_PARMSW mdsp32w = (LPMCI_DGV_STATUS_PARMSW)lParam;
-            char *base = (char*)lParam - sizeof(LPMCI_DGV_STATUS_PARMS16);
-            LPMCI_DGV_STATUS_PARMS16 mdsp16 = *(LPMCI_DGV_STATUS_PARMS16*)base;
-            mdsp16->dwReturn = mdsp32w->dwReturn;
-            HeapFree(GetProcessHeap(), 0, (LPVOID)mdsp32w->lpstrDrive);
-            HeapFree(GetProcessHeap(), 0, base);
+        if (lParam)
+        {
+            if (dwFlags & (MCI_DGV_STATUS_REFERENCE | MCI_DGV_STATUS_DISKSPACE))
+            {
+                LPMCI_DGV_STATUS_PARMSW mdsp32w = (LPMCI_DGV_STATUS_PARMSW)lParam;
+                char *base = (char*)lParam - sizeof(LPMCI_DGV_STATUS_PARMS16);
+                LPMCI_DGV_STATUS_PARMS16 mdsp16 = *(LPMCI_DGV_STATUS_PARMS16*)base;
+                mdsp16->dwReturn = mdsp32w->dwReturn;
+                HeapFree(GetProcessHeap(), 0, (LPVOID)mdsp32w->lpstrDrive);
+                HeapFree(GetProcessHeap(), 0, base);
+            }
+            else if (dwFlags & MCI_STATUS_ITEM)
+            {
+                LPMCI_STATUS_PARMS msp = lParam;
+                if (msp->dwItem == 0x4001) // MCI_DGV_STATUS_HWND
+                    msp->dwReturn = (DWORD_PTR)HWND_16((HWND)(msp->dwReturn));
+            }
         }
         break;
     case MCI_WINDOW:
@@ -749,7 +936,12 @@ DWORD WINAPI mciSendCommand16(UINT16 wDevID, UINT16 wMsg, DWORD dwParam1, DWORD
             dwRet = mciSendCommandW(wDevID, wMsg, dwParam1, dwParam2);
             RestoreThunkLock(count);
             if (res == MMSYSTEM_MAP_OKMEM)
-                MCI_UnMapMsg16To32W(wMsg, dwParam1, dwParam2, dwRet);
+            {
+                if (!p2)
+                    HeapFree(GetProcessHeap(), 0, dwParam2);
+                else
+                    MCI_UnMapMsg16To32W(wMsg, dwParam1, dwParam2, dwRet);
+            }
             break;
         }
     }
@@ -817,7 +1009,11 @@ UINT16 WINAPI mciDriverYield16(UINT16 uDeviceID)
 DWORD WINAPI mciSendString16(LPCSTR lpstrCommand, LPSTR lpstrRet,
 			     UINT16 uRetLen, HWND16 hwndCallback)
 {
-    return mciSendStringA(lpstrCommand, lpstrRet, uRetLen, HWND_32(hwndCallback));
+    char newstr[128];
+    DWORD ret = mciSendStringA(xlate_str_handle(lpstrCommand, newstr), lpstrRet, uRetLen, HWND_32(hwndCallback));
+    if (!ret && lpstrRet && !strncmp(lpstrCommand, "status ", 7))
+        xlate_stat_handle(lpstrCommand, lpstrRet);
+    return ret;
 }
 
 /**************************************************************************
diff --git a/dlls/mmsystem.dll16/message16.c b/dlls/mmsystem.dll16/message16.c
index 64382ae070b..0f8884f8f91 100644
--- a/dlls/mmsystem.dll16/message16.c
+++ b/dlls/mmsystem.dll16/message16.c
@@ -101,9 +101,16 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
     {
         case MIDM_GETNUMDEVS:
         case MIDM_RESET:
+        case MIDM_START:
+        case MIDM_STOP:
             ret = MMSYSTEM_MAP_OK;
             break;
 
+        case MIDM_OPEN:
+        case MIDM_CLOSE:
+            FIXME("Shouldn't be used: the corresponding 16 bit functions use the 32 bit interface\n");
+            break;
+
         case MIDM_GETDEVCAPS:
             {
                 LPMIDIINCAPSW  mic32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIINCAPS16) + sizeof(MIDIINCAPSW));
@@ -123,44 +130,43 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
             }
             break;
 
-        case MIDM_ADDBUFFER:
         case MIDM_PREPARE:
             {
-                struct mihdrWrap   *mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(struct mihdrWrap));
-                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
-
-                if (mh32)
-                {
-                    mh32->ref = 2;
-                    mh32->mh16 = (SEGPTR)*lpParam1;
-                    mh32->hdr.lpData = MapSL((SEGPTR)mh16->lpData);
-                    mh32->hdr.dwBufferLength = mh16->dwBufferLength;
-                    mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
-                    mh32->hdr.dwUser = mh16->dwUser;
-                    mh32->hdr.dwFlags = mh16->dwFlags;
-                    mh16->lpNext = (MIDIHDR16*)mh32;
-                    *lpParam1 = (DWORD)&mh32->hdr;
-                    *lpParam2 = offsetof(MIDIHDR,dwOffset);
+                LPMIDIHDR mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIHDR) + sizeof(MIDIHDR));
+                LPMIDIHDR16 mh16 = MapSL(*lpParam1);
+
+                if (mh32) {
+                    *(LPMIDIHDR*)mh32 = (LPMIDIHDR)*lpParam1;
+                    mh32 = (LPMIDIHDR)((LPSTR)mh32 + sizeof(LPMIDIHDR));
+                    mh32->lpData = MapSL((SEGPTR)mh16->lpData);
+                    mh32->dwBufferLength = mh16->dwBufferLength;
+                    mh32->dwBytesRecorded = mh16->dwBytesRecorded;
+                    mh32->dwUser = mh16->dwUser;
+                    mh32->dwFlags = mh16->dwFlags;
+                    mh16->reserved = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
+                    *lpParam1 = (DWORD)mh32;
+                    *lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
 
                     ret = MMSYSTEM_MAP_OKMEM;
-                }
-                else
+                } else {
                     ret = MMSYSTEM_MAP_NOMEM;
+                }
             }
             break;
 
+        case MIDM_ADDBUFFER:
         case MIDM_UNPREPARE:
             {
-                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
-                struct mihdrWrap   *mh32 = (struct mihdrWrap *)mh16->lpNext;
+                LPMIDIHDR16 mh16 = MapSL(*lpParam1);
+                LPMIDIHDR mh32 = (MIDIHDR*)mh16->reserved;
 
-                mh32->ref++;
-
-                *lpParam1 = (DWORD)&mh32->hdr;
+                *lpParam1 = (DWORD)mh32;
                 *lpParam2 = offsetof(MIDIHDR,dwOffset);
-
-                mh32->hdr.dwBufferLength = mh16->dwBufferLength;
-
+                if (wMsg == MIDM_ADDBUFFER && mh32->dwBufferLength < mh16->dwBufferLength) {
+                    ERR("Size of buffer has been increased from %d to %d, keeping initial value\n",
+                        mh32->dwBufferLength, mh16->dwBufferLength);
+                } else
+                            mh32->dwBufferLength = mh16->dwBufferLength;
                 ret = MMSYSTEM_MAP_OKMEM;
             }
             break;
@@ -180,9 +186,16 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_UnMap16To32W(DWORD wMsg, DWORD_PTR* lp
     {
         case MIDM_GETNUMDEVS:
         case MIDM_RESET:
+        case MIDM_START:
+        case MIDM_STOP:
             ret = MMSYSTEM_MAP_OK;
             break;
 
+        case MIDM_OPEN:
+        case MIDM_CLOSE:
+            FIXME("Shouldn't be used: the corresponding 16 bit functions use the 32 bit interface\n");
+            break;
+
         case MIDM_GETDEVCAPS:
             {
                 LPMIDIINCAPSW   mic32 = (LPMIDIINCAPSW)(*lpParam1);
@@ -201,31 +214,21 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_UnMap16To32W(DWORD wMsg, DWORD_PTR* lp
 
         case MIDM_PREPARE:
         case MIDM_UNPREPARE:
+        case MIDM_ADDBUFFER:
             {
-                struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*lpParam1, struct mihdrWrap, hdr);
-                LPMIDIHDR16         mh16;
-
-                if (mh32->mh16)
-                {
-                    mh16 = MapSL(mh32->mh16);
-                    assert((struct mihdrWrap *)mh16->lpNext == mh32);
-                    mh16->dwFlags = mh32->hdr.dwFlags;
-
-                    if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
-                    {
-                        mh32->mh16 = 0;
-                        mh32->ref--;
-                        mh16->lpNext = 0;
-                    }
-                }
+                LPMIDIHDR mh32 = (LPMIDIHDR)(*lpParam1);
+                LPMIDIHDR16 mh16 = MapSL(*(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR)));
 
-                if (!--mh32->ref)
-                    HeapFree(GetProcessHeap(), 0, mh32);
+                assert((MIDIHDR*)mh16->reserved == mh32);
+                mh16->dwFlags = mh32->dwFlags;
 
+                if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR) {
+                    HeapFree(GetProcessHeap(), 0, (LPSTR)mh32 - sizeof(LPMIDIHDR));
+                    mh16->reserved = 0;
+                }
                 ret = MMSYSTEM_MAP_OK;
             }
             break;
-
     }
     return ret;
 }
@@ -318,7 +321,7 @@ static MMSYSTEM_MapType	MMSYSTDRV_MidiOut_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
             mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
             mh32->hdr.dwUser = mh16->dwUser;
             mh32->hdr.dwFlags = mh16->dwFlags;
-            mh16->lpNext = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
+            mh16->reserved = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
             *lpParam1 = (DWORD)&mh32->hdr;
             *lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
 
@@ -332,7 +335,7 @@ static MMSYSTEM_MapType	MMSYSTDRV_MidiOut_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
     case MODM_LONGDATA:
 	{
         LPMIDIHDR16         mh16 = MapSL(*lpParam1);
-        struct mihdrWrap   *mh32 = (struct mihdrWrap*)mh16->lpNext;
+        struct mihdrWrap   *mh32 = (struct mihdrWrap*)mh16->reserved;
 
         mh32->ref++;
 
@@ -412,14 +415,14 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiOut_UnMap16To32W(DWORD wMsg, DWORD_PTR* l
         if (mh32->mh16)
         {
             mh16 = MapSL(mh32->mh16);
-            assert((struct mihdrWrap *)mh16->lpNext == mh32);
+            assert((struct mihdrWrap *)mh16->reserved == mh32);
             mh16->dwFlags = mh32->hdr.dwFlags;
 
             if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
             {
                 mh32->mh16 = 0;
                 mh32->ref--;
-                mh16->lpNext = 0;
+                mh16->reserved = 0;
             }
         }
 
@@ -543,7 +546,7 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
 		wh32->dwLoops = wh16->dwLoops;
 		/* FIXME: nothing on wh32->lpNext */
 		/* could link the wh32->lpNext at this level for memory house keeping */
-		wh16->lpNext = wh32; /* for reuse in unprepare and write */
+		wh16->reserved = wh32; /* for reuse in unprepare and write */
 		*lpParam1 = (DWORD)wh32;
 		*lpParam2 = sizeof(WAVEHDR);
 
@@ -557,7 +560,7 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
     case WIDM_UNPREPARE:
 	{
 	    LPWAVEHDR		wh16 = MapSL(*lpParam1);
-	    LPWAVEHDR		wh32 = wh16->lpNext;
+	    LPWAVEHDR		wh32 = wh16->reserved;
 
 	    *lpParam1 = (DWORD)wh32;
 	    *lpParam2 = sizeof(WAVEHDR);
@@ -634,13 +637,13 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveIn_UnMap16To32W(DWORD wMsg, DWORD_PTR* lp
 	    LPWAVEHDR		wh32 = (LPWAVEHDR)(*lpParam1);
 	    LPWAVEHDR		wh16 = MapSL(*(SEGPTR*)((LPSTR)wh32 - sizeof(LPWAVEHDR)));
 
-	    assert(wh16->lpNext == wh32);
+	    assert(wh16->reserved == wh32);
 	    wh16->dwBytesRecorded = wh32->dwBytesRecorded;
 	    wh16->dwFlags = wh32->dwFlags;
 
 	    if (wMsg == WIDM_UNPREPARE && fn_ret == MMSYSERR_NOERROR) {
 		HeapFree(GetProcessHeap(), 0, (LPSTR)wh32 - sizeof(LPWAVEHDR));
-		wh16->lpNext = 0;
+		wh16->reserved = 0;
 	    }
 	    ret = MMSYSTEM_MAP_OK;
 	}
@@ -763,7 +766,7 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveOut_Map16To32W  (DWORD wMsg, DWORD_PTR* l
 		wh32->dwLoops = wh16->dwLoops;
 		/* FIXME: nothing on wh32->lpNext */
 		/* could link the wh32->lpNext at this level for memory house keeping */
-		wh16->lpNext = wh32; /* for reuse in unprepare and write */
+		wh16->reserved = wh32; /* for reuse in unprepare and write */
 		*lpParam1 = (DWORD)wh32;
 		*lpParam2 = sizeof(WAVEHDR);
 
@@ -777,15 +780,17 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveOut_Map16To32W  (DWORD wMsg, DWORD_PTR* l
     case WODM_WRITE:
 	{
 	    LPWAVEHDR		wh16 = MapSL(*lpParam1);
-	    LPWAVEHDR		wh32 = wh16->lpNext;
+	    LPWAVEHDR		wh32 = wh16->reserved;
+            if (wMsg == WODM_UNPREPARE)
+                wh32->dwFlags = wh16->dwFlags;
 
 	    *lpParam1 = (DWORD)wh32;
 	    *lpParam2 = sizeof(WAVEHDR);
 	    /* dwBufferLength can be reduced between prepare & write */
-	    if (wMsg == WODM_WRITE && wh32->dwBufferLength < wh16->dwBufferLength) {
+/*	    if (wMsg == WODM_WRITE && wh32->dwBufferLength < wh16->dwBufferLength) {
 		ERR("Size of buffer has been increased from %ld to %ld, keeping initial value\n",
 		    wh32->dwBufferLength, wh16->dwBufferLength);
-	    } else
+	    } else */
                 wh32->dwBufferLength = wh16->dwBufferLength;
 	    ret = MMSYSTEM_MAP_OKMEM;
 	}
@@ -864,12 +869,12 @@ static  MMSYSTEM_MapType	MMSYSTDRV_WaveOut_UnMap16To32W(DWORD wMsg, DWORD_PTR* l
 	    LPWAVEHDR		wh32 = (LPWAVEHDR)(*lpParam1);
 	    LPWAVEHDR		wh16 = MapSL(*(SEGPTR*)((LPSTR)wh32 - sizeof(LPWAVEHDR)));
 
-	    assert(wh16->lpNext == wh32);
+	    assert(wh16->reserved == wh32);
 	    wh16->dwFlags = wh32->dwFlags;
 
 	    if (wMsg == WODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR) {
 		HeapFree(GetProcessHeap(), 0, (LPSTR)wh32 - sizeof(LPWAVEHDR));
-		wh16->lpNext = 0;
+		wh16->reserved = 0;
 	    }
 	    ret = MMSYSTEM_MAP_OK;
 	}
@@ -1057,6 +1062,7 @@ struct mmsystdrv_thunk*       MMSYSTDRV_AddThunk(DWORD callback, DWORD flags, en
 static void*    MMSYSTDRV_FindHandle(void* h)
 {
     struct mmsystdrv_thunk* thunk;
+    if (!h) return NULL;
 
     for (thunk = MMSYSTDRV_Thunks; thunk < &MMSYSTDRV_Thunks[MMSYSTDRV_MAX_THUNKS]; thunk++)
     {
diff --git a/dlls/mmsystem.dll16/mmio16.c b/dlls/mmsystem.dll16/mmio16.c
index 982bdc88015..5e023218b57 100644
--- a/dlls/mmsystem.dll16/mmio16.c
+++ b/dlls/mmsystem.dll16/mmio16.c
@@ -41,16 +41,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(mmsys);
  * ###################################################
  */
 #include <pshpack1.h>
-#define MMIO_MAX_THUNKS      32
+#define MMIO_MAX_THUNKS      64
 
 static struct mmio_thunk
 {
     BYTE        popl_eax;       /* popl  %eax (return address) */
-    BYTE        pushl_func;     /* pushl $pfn16 (16bit callback function) */
-    LPMMIOPROC16 pfn16;
+    BYTE        pushl_func;     /* pushl $this */
+    struct mmio_thunk *this;
     BYTE        pushl_eax;      /* pushl %eax */
     BYTE        jmp;            /* ljmp MMIO_Callback1632 */
     DWORD       callback;
+    LPMMIOPROC16 pfn16;
     HMMIO       hMmio;          /* Handle to 32bit mmio object */
     SEGPTR      segbuffer;      /* actual segmented ptr to buffer */
     HGLOBAL16   allocbuf;       /* MMIO_ALLOCBUF */
@@ -70,7 +71,7 @@ static CRITICAL_SECTION mmio_cs = { &mmio_critsect_debug, -1, 0, 0, 0, 0 };
 /****************************************************************
  *       		MMIO_Map32To16			[INTERNAL]
  */
-static LRESULT	MMIO_Map32To16(DWORD wMsg, LPARAM* lp1, LPARAM* lp2)
+static LRESULT	MMIO_Map32To16(struct mmio_thunk *thunk, DWORD wMsg, LPARAM* lp1, LPARAM* lp2, DWORD cch)
 {
     switch (wMsg) {
     case MMIOM_CLOSE:
@@ -78,9 +79,30 @@ static LRESULT	MMIO_Map32To16(DWORD wMsg, LPARAM* lp1, LPARAM* lp2)
 	/* nothing to do */
 	break;
     case MMIOM_OPEN:
+        *lp1 = MapLS( (void *)*lp1 );
+        break;
     case MMIOM_READ:
     case MMIOM_WRITE:
     case MMIOM_WRITEFLUSH:
+        if (*lp2 > cch) {
+            int size = *lp2;
+            int count = (size + 0xffff) / 0x10000;
+            WORD sel = AllocSelectorArray16(count);
+            for (int i = 0; i < count; i++) {
+                SetSelectorBase(sel + (i << __AHSHIFT), (DWORD)*lp1 + i * 0x10000);
+                SetSelectorLimit16(sel + (i << __AHSHIFT), size - 1);
+                size -= 0x10000;
+            }
+            *lp1 = sel << 16;
+            break;
+        } else if (thunk->segbuffer) {
+            int offset = *lp1 - (INT_PTR)MapSL(thunk->segbuffer);
+            if ((offset <= 0xffff) && (offset <= GlobalSize16(SELECTOROF(thunk->segbuffer))))
+            {
+                *lp1 = thunk->segbuffer + offset;
+                break;
+            }
+        }
         *lp1 = MapLS( (void *)*lp1 );
 	break;
     case MMIOM_RENAME:
@@ -97,8 +119,8 @@ static LRESULT	MMIO_Map32To16(DWORD wMsg, LPARAM* lp1, LPARAM* lp2)
 /****************************************************************
  *       	MMIO_UnMap32To16 			[INTERNAL]
  */
-static LRESULT	MMIO_UnMap32To16(DWORD wMsg, LPARAM lParam1, LPARAM lParam2,
-				 LPARAM lp1, LPARAM lp2)
+static LRESULT	MMIO_UnMap32To16(struct mmio_thunk *thunk, DWORD wMsg, LPARAM lParam1, LPARAM lParam2,
+				 LPARAM lp1, LPARAM lp2, DWORD cch)
 {
     switch (wMsg) {
     case MMIOM_CLOSE:
@@ -106,10 +128,19 @@ static LRESULT	MMIO_UnMap32To16(DWORD wMsg, LPARAM lParam1, LPARAM lParam2,
 	/* nothing to do */
 	break;
     case MMIOM_OPEN:
+        UnMapLS( lp1 );
+        break;
     case MMIOM_READ:
     case MMIOM_WRITE:
     case MMIOM_WRITEFLUSH:
-        UnMapLS( lp1 );
+        if (lp2 > cch) {
+            int count = (lp2 + 0xffff) / 0x10000;
+            WORD sel = SELECTOROF(lp1);
+            for (int i = 0; i < count; i++) {
+                FreeSelector16(sel + (i << __AHSHIFT));
+            }
+        } else if (SELECTOROF(thunk->segbuffer) != SELECTOROF(lp1))
+            UnMapLS( lp1 );
 	break;
     case MMIOM_RENAME:
         UnMapLS( lp1 );
@@ -122,12 +153,28 @@ static LRESULT	MMIO_UnMap32To16(DWORD wMsg, LPARAM lParam1, LPARAM lParam2,
     return MMSYSERR_NOERROR;
 }
 
+/******************************************************************
+ *		MMIO_HasThunk
+ *
+ */
+static struct mmio_thunk* MMIO_HasThunk(HMMIO hmmio)
+{
+    struct mmio_thunk* thunk;
+
+    if (!MMIO_Thunks) return NULL;
+    for (thunk = MMIO_Thunks; thunk < &MMIO_Thunks[MMIO_MAX_THUNKS]; thunk++)
+    {
+        if (thunk->hMmio == hmmio) return thunk;
+    }
+    return NULL;
+}
+
 /******************************************************************
  *		MMIO_Callback3216
  *
  *
  */
-static LRESULT CALLBACK MMIO_Callback3216(SEGPTR cb16, LPMMIOINFO lpmmioinfo, UINT uMessage,
+static LRESULT CALLBACK MMIO_Callback3216(struct mmio_thunk *thunk, LPMMIOINFO lpmmioinfo, UINT uMessage,
                                  LPARAM lParam1, LPARAM lParam2)
 {
     DWORD 		result;
@@ -135,16 +182,25 @@ static LRESULT CALLBACK MMIO_Callback3216(SEGPTR cb16, LPMMIOINFO lpmmioinfo, UI
     SEGPTR		segmmioInfo16;
     LPARAM		lp1 = lParam1, lp2 = lParam2;
     WORD                args[7];
+    SEGPTR              cb16 = thunk->pfn16;
 
     if (!cb16) return MMSYSERR_INVALPARAM;
 
+    if (thunk->hMmio != lpmmioinfo->hmmio)
+    {
+        struct mmio_thunk *realfile = MMIO_HasThunk(lpmmioinfo->hmmio);
+        if (realfile)
+            thunk = realfile;
+    }
+
     memset(&mmioInfo16, 0, sizeof(MMIOINFO16));
+    mmioInfo16.dwFlags = lpmmioinfo->dwFlags;
     mmioInfo16.lDiskOffset = lpmmioinfo->lDiskOffset;
     mmioInfo16.adwInfo[0]  = lpmmioinfo->adwInfo[0];
     mmioInfo16.adwInfo[1]  = lpmmioinfo->adwInfo[1];
     mmioInfo16.adwInfo[2]  = lpmmioinfo->adwInfo[2];
     /* map (lParam1, lParam2) into (lp1, lp2) 32=>16 */
-    if ((result = MMIO_Map32To16(uMessage, &lp1, &lp2)) != MMSYSERR_NOERROR)
+    if ((result = MMIO_Map32To16(thunk, uMessage, &lp1, &lp2, lpmmioinfo->cchBuffer)) != MMSYSERR_NOERROR)
         return result;
 
     segmmioInfo16 = MapLS(&mmioInfo16);
@@ -157,7 +213,7 @@ static LRESULT CALLBACK MMIO_Callback3216(SEGPTR cb16, LPMMIOINFO lpmmioinfo, UI
     args[0] = LOWORD(lp2);
     WOWCallback16Ex( cb16, WCB16_PASCAL, sizeof(args), args, &result );
     UnMapLS(segmmioInfo16);
-    MMIO_UnMap32To16(uMessage, lParam1, lParam2, lp1, lp2);
+    MMIO_UnMap32To16(thunk, uMessage, lParam1, lParam2, lp1, lp2, lpmmioinfo->cchBuffer);
 
     lpmmioinfo->lDiskOffset = mmioInfo16.lDiskOffset;
     lpmmioinfo->adwInfo[0]  = mmioInfo16.adwInfo[0];
@@ -183,11 +239,12 @@ static struct mmio_thunk*       MMIO_AddThunk(LPMMIOPROC16 pfn16, HPSTR segbuf)
         for (thunk = MMIO_Thunks; thunk < &MMIO_Thunks[MMIO_MAX_THUNKS]; thunk++)
         {
             thunk->popl_eax     = 0x58;   /* popl  %eax */
-            thunk->pushl_func   = 0x68;   /* pushl $pfn16 */
-            thunk->pfn16        = 0;
+            thunk->pushl_func   = 0x68;   /* pushl $this */
+            thunk->this         = thunk;
             thunk->pushl_eax    = 0x50;   /* pushl %eax */
             thunk->jmp          = 0xe9;   /* jmp MMIO_Callback3216 */
             thunk->callback     = (char *)MMIO_Callback3216 - (char *)(&thunk->callback + 1);
+            thunk->pfn16        = 0;
             thunk->hMmio        = NULL;
             thunk->segbuffer    = 0;
             thunk->allocbuf     = NULL;
@@ -207,22 +264,6 @@ static struct mmio_thunk*       MMIO_AddThunk(LPMMIOPROC16 pfn16, HPSTR segbuf)
     return NULL;
 }
 
-/******************************************************************
- *		MMIO_HasThunk
- *
- */
-static struct mmio_thunk*    MMIO_HasThunk(HMMIO hmmio)
-{
-    struct mmio_thunk* thunk;
-
-    if (!MMIO_Thunks) return NULL;
-    for (thunk = MMIO_Thunks; thunk < &MMIO_Thunks[MMIO_MAX_THUNKS]; thunk++)
-    {
-        if (thunk->hMmio == hmmio) return thunk;
-    }
-    return NULL;
-}
-
 /******************************************************************
  *             MMIO_SetSegmentedBuffer
  *
@@ -250,10 +291,11 @@ HMMIO16 WINAPI mmioOpen16(LPSTR szFileName, MMIOINFO16* lpmmioinfo16,
 			  DWORD dwOpenFlags)
 {
     HMMIO 	ret;
+    struct mmio_thunk*      thunk = NULL;
+    HGLOBAL16 hg;
 
     if (lpmmioinfo16) {
 	MMIOINFO	        mmioinfo;
-        struct mmio_thunk*      thunk = NULL;
 
 	memset(&mmioinfo, 0, sizeof(mmioinfo));
 
@@ -287,7 +329,7 @@ HMMIO16 WINAPI mmioOpen16(LPSTR szFileName, MMIOINFO16* lpmmioinfo16,
         {
             if (lpmmioinfo16->pchBuffer) FIXME("ooch\n");
             /* FIXME: check whether mmioOpen should set pchBuffer */
-            HGLOBAL hg = GlobalAlloc16(0, lpmmioinfo16->cchBuffer);
+            hg = GlobalAlloc16(0, lpmmioinfo16->cchBuffer);
             mmioSetBuffer(ret, GlobalLock16(hg), lpmmioinfo16->cchBuffer, 0);
             /* OFFSETOF(segbuffer) must be 0x0000 */
             thunk->segbuffer = WOWGlobalLock16(hg);
@@ -298,7 +340,19 @@ HMMIO16 WINAPI mmioOpen16(LPSTR szFileName, MMIOINFO16* lpmmioinfo16,
 	lpmmioinfo16->wErrorRet = mmioinfo.wErrorRet;
         lpmmioinfo16->hmmio     = HMMIO_16(mmioinfo.hmmio);
     } else {
-	ret = mmioOpenA(szFileName, NULL, dwOpenFlags);
+        EnterCriticalSection(&mmio_cs);
+        if (!(thunk = MMIO_AddThunk(NULL, 0)))
+        {
+            LeaveCriticalSection(&mmio_cs);
+            return 0;
+        }
+        ret = mmioOpenA(szFileName, NULL, dwOpenFlags);
+        if (!ret || (dwOpenFlags & (MMIO_PARSE|MMIO_EXIST)))
+            thunk->hMmio = NULL;
+        else thunk->hMmio = ret;
+        thunk->segbuffer = 0;
+        thunk->allocbuf = NULL;
+        LeaveCriticalSection(&mmio_cs);
     }
     return HMMIO_16(ret);
 }
@@ -368,6 +422,8 @@ MMRESULT16 WINAPI mmioGetInfo16(HMMIO16 hmmio, MMIOINFO16* lpmmioinfo, UINT16 uF
         LeaveCriticalSection(&mmio_cs);
 	return MMSYSERR_INVALHANDLE;
     }
+    if (!thunk->segbuffer)
+        FIXME("NULL segbuffer\n");
 
     ret = mmioGetInfo(HMMIO_32(hmmio), &mmioinfo, uFlags);
     if (ret != MMSYSERR_NOERROR)
@@ -476,33 +532,21 @@ MMRESULT16 WINAPI mmioFlush16(HMMIO16 hmmio, UINT16 uFlags)
  */
 MMRESULT16 WINAPI mmioAdvance16(HMMIO16 hmmio, MMIOINFO16* lpmmioinfo, UINT16 uFlags)
 {
-    MMIOINFO    mmioinfo = { 0 };
     LRESULT     ret;
 
-    /* WARNING: this heavily relies on mmioAdvance implementation (for choosing which
-     * fields to init
-     */
     if (lpmmioinfo)
     {
-        mmioinfo.pchBuffer = MapSL((DWORD)lpmmioinfo->pchBuffer);
-        mmioinfo.pchNext = MapSL((DWORD)lpmmioinfo->pchNext);
-        mmioinfo.dwFlags = lpmmioinfo->dwFlags;
-        mmioinfo.lBufOffset = lpmmioinfo->lBufOffset;
-        ret = mmioAdvance(HMMIO_32(hmmio), &mmioinfo, uFlags);
+        ret = mmioSetInfo16(hmmio, lpmmioinfo, 0);
+        if (ret != MMSYSERR_NOERROR) return ret;
     }
-    else
-        ret = mmioAdvance(HMMIO_32(hmmio), NULL, uFlags);
 
+    ret = mmioAdvance(HMMIO_32(hmmio), NULL, uFlags);
     if (ret != MMSYSERR_NOERROR) return ret;
 
     if (lpmmioinfo)
     {
-        lpmmioinfo->dwFlags = mmioinfo.dwFlags;
-        lpmmioinfo->pchNext     = (void*)(lpmmioinfo->pchBuffer + (mmioinfo.pchNext - mmioinfo.pchBuffer));
-        lpmmioinfo->pchEndRead  = (void*)(lpmmioinfo->pchBuffer + (mmioinfo.pchEndRead - mmioinfo.pchBuffer));
-        lpmmioinfo->pchEndWrite = (void*)(lpmmioinfo->pchBuffer + (mmioinfo.pchEndWrite - mmioinfo.pchBuffer));
-        lpmmioinfo->lBufOffset  = mmioinfo.lBufOffset;
-        lpmmioinfo->lDiskOffset = mmioinfo.lDiskOffset;
+        ret = mmioGetInfo16(hmmio, lpmmioinfo, 0);
+        if (ret != MMSYSERR_NOERROR) return ret;
     }
 
     return MMSYSERR_NOERROR;
diff --git a/dlls/mmsystem.dll16/mmsystem.c b/dlls/mmsystem.dll16/mmsystem.c
index 49b901335b7..879f9330201 100644
--- a/dlls/mmsystem.dll16/mmsystem.c
+++ b/dlls/mmsystem.dll16/mmsystem.c
@@ -30,7 +30,8 @@
 #include <string.h>
 
 #define NONAMELESSUNION
-
+#undef DUMMYSTRUCTNAME
+#undef DUMMYUNIONNAME
 #include "windef.h"
 #include "winbase.h"
 #include "mmsystem.h"
@@ -41,6 +42,7 @@
 #include "wine/list.h"
 #include "wine/winuser16.h"
 #include "winemm16.h"
+#include "mmreg.h"
 
 #include "wine/debug.h"
 
@@ -294,9 +296,18 @@ BOOL16 WINAPI sndPlaySound16(LPCSTR lpszSoundName, UINT16 uFlags)
 {
     BOOL16	retv;
     DWORD	lc;
+    char	buf[36];
+    if ((uFlags & SND_MEMORY) && (*(DWORD *)(lpszSoundName + 4) < 36))
+    {
+        memset(buf, 0, 36);
+        memcpy(buf, lpszSoundName, *(DWORD *)(lpszSoundName + 4));
+        lpszSoundName = buf;
+    }
 
     ReleaseThunkLock(&lc);
     retv = sndPlaySoundA(lpszSoundName, uFlags);
+    if ((uFlags & SND_ASYNC) && retv)
+        Sleep(1);
     RestoreThunkLock(lc);
 
     return retv;
@@ -384,21 +395,25 @@ UINT16 WINAPI mixerOpen16(LPHMIXER16 lphmix, UINT16 uDeviceID, DWORD dwCallback,
 {
     HMIXER	                hmix;
     UINT	                ret;
-    struct mmsystdrv_thunk*     thunk;
 
-    if (!(thunk = MMSYSTDRV_AddThunk(dwCallback, fdwOpen, MMSYSTDRV_MIXER)))
+    /*
+     * mixer doesn't support CALLBACK_FUNCTION without which only CALLBACK_WINDOW isn't difficult 
+     * wine source says CALLBACK_THREAD and CALLBACK_EVENT weren't supported until win2k
+     */
+    if (fdwOpen & CALLBACK_TYPEMASK)
     {
-        return MMSYSERR_NOMEM;
+        if ((fdwOpen & CALLBACK_TYPEMASK) != CALLBACK_WINDOW)
+        {
+            ERR("called with unsupported callback type %x\n", fdwOpen & CALLBACK_TYPEMASK);
+            return MMSYSERR_NOTSUPPORTED;
+        }
+        dwCallback = HWND_32(dwCallback);
     }
-    if ((fdwOpen & CALLBACK_TYPEMASK) != CALLBACK_NULL)
-        fdwOpen = (fdwOpen & ~CALLBACK_TYPEMASK) | CALLBACK_FUNCTION;
-    ret = mixerOpen(&hmix, uDeviceID, (DWORD)thunk, dwInstance, fdwOpen);
+    ret = mixerOpen(&hmix, uDeviceID, dwCallback, dwInstance, fdwOpen);
     if (ret == MMSYSERR_NOERROR)
     {
         if (lphmix) *lphmix = HMIXER_16(hmix);
-        if (thunk) MMSYSTDRV_SetHandle(thunk, hmix);
     }
-    else MMSYSTDRV_DeleteThunk(thunk);
     return ret;
 }
 
@@ -407,11 +422,7 @@ UINT16 WINAPI mixerOpen16(LPHMIXER16 lphmix, UINT16 uDeviceID, DWORD dwCallback,
  */
 UINT16 WINAPI mixerClose16(HMIXER16 hMix)
 {
-    UINT        ret = mixerClose(HMIXER_32(hMix));
-
-    if (ret == MMSYSERR_NOERROR)
-        MMSYSTDRV_CloseHandle((void*)HMIXER_32(hMix));
-    return ret;
+    return mixerClose(HMIXER_32(hMix));
 }
 
 /**************************************************************************
@@ -997,9 +1008,13 @@ UINT16 WINAPI midiInAddBuffer16(HMIDIIN16 hMidiIn,         /* [in] */
                                 SEGPTR lpsegMidiInHdr,     /* [???] */
 				UINT16 uSize)              /* [in] */
 {
-    TRACE("(%04X, %08lx, %d)\n", hMidiIn, lpsegMidiInHdr, uSize);
+    DWORD level;
+    TRACE("(%04X, %08x, %d)\n", hMidiIn, lpsegMidiInHdr, uSize);
+    ReleaseThunkLock(&level);
 
-    return MMSYSTDRV_Message(HMIDIIN_32(hMidiIn), MIDM_ADDBUFFER, lpsegMidiInHdr, uSize);
+    UINT16 ret = MMSYSTDRV_Message(HMIDIIN_32(hMidiIn), MIDM_ADDBUFFER, lpsegMidiInHdr, uSize);
+    RestoreThunkLock(level);
+    return ret;
 }
 
 /**************************************************************************
@@ -1215,6 +1230,34 @@ UINT16 WINAPI waveOutGetErrorText16(UINT16 uError, LPSTR lpText, UINT16 uSize)
     return waveOutGetErrorTextA(uError, lpText, uSize);
 }
 
+static void init_wfx_adpcm(ADPCMWAVEFORMAT* awfx)
+{
+    register WAVEFORMATEX* pwfx = &awfx->wfx;
+    static ADPCMCOEFSET MSADPCM_CoeffSet[] =
+    {
+        {256, 0}, {512, -256}, {0, 0}, {192, 64}, {240, 0}, {460, -208}, {392, -232}
+    };
+
+    /* we assume wFormatTag, nChannels, nSamplesPerSec and wBitsPerSample
+     * have been initialized... */
+
+    switch (pwfx->nSamplesPerSec)
+    {
+        case  8000: pwfx->nBlockAlign = 256 * pwfx->nChannels;  break;
+        case 11025: pwfx->nBlockAlign = 256 * pwfx->nChannels;  break;
+        case 22050: pwfx->nBlockAlign = 512 * pwfx->nChannels;  break;
+        case 44100: pwfx->nBlockAlign = 1024 * pwfx->nChannels; break;
+        default:                                                break;
+    }
+    pwfx->cbSize = 2 * sizeof(WORD) + 7 * sizeof(ADPCMCOEFSET);
+    /* 7 is the size of the block head (which contains two samples) */
+
+    awfx->wSamplesPerBlock = pwfx->nBlockAlign * 2 / pwfx->nChannels - 12;
+    pwfx->nAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign) / awfx->wSamplesPerBlock;
+    awfx->wNumCoef = 7;
+    memcpy(awfx->aCoef, MSADPCM_CoeffSet, 7 * sizeof(ADPCMCOEFSET));
+}
+
 /**************************************************************************
  *			waveOutOpen			[MMSYSTEM.404]
  */
@@ -1225,6 +1268,11 @@ UINT16 WINAPI waveOutOpen16(HWAVEOUT16* lphWaveOut, UINT16 uDeviceID,
     HWAVEOUT		        hWaveOut;
     UINT		        ret;
     struct mmsystdrv_thunk*     thunk;
+    WAVEFORMATEX                *wavefmt;
+    WORD                        size = lpFormat->wFormatTag == WAVE_FORMAT_PCM ? 0 : lpFormat->cbSize;
+    wavefmt = (WAVEFORMATEX *)HeapAlloc(GetProcessHeap(), 0, sizeof(WAVEFORMATEX) + size);
+
+    memcpy(wavefmt, lpFormat, sizeof(WAVEFORMATEX) + size);
 
     if (!(thunk = MMSYSTDRV_AddThunk(dwCallback, dwFlags, MMSYSTDRV_WAVEOUT)))
     {
@@ -1243,8 +1291,11 @@ UINT16 WINAPI waveOutOpen16(HWAVEOUT16* lphWaveOut, UINT16 uDeviceID,
      * however, we need to promote correctly the wave mapper id
      * (0xFFFFFFFF and not 0x0000FFFF)
      */
+    if (wavefmt->wFormatTag == WAVE_FORMAT_ADPCM)
+        init_wfx_adpcm((ADPCMWAVEFORMAT*) wavefmt);
+
     ret = waveOutOpen(&hWaveOut, (uDeviceID == (UINT16)-1) ? (UINT)-1 : uDeviceID,
-                      lpFormat, (DWORD)thunk, dwInstance, dwFlags);
+                      wavefmt, (DWORD)thunk, dwInstance, dwFlags);
 
     if (ret == MMSYSERR_NOERROR && !(dwFlags & WAVE_FORMAT_QUERY))
     {
@@ -1252,6 +1303,7 @@ UINT16 WINAPI waveOutOpen16(HWAVEOUT16* lphWaveOut, UINT16 uDeviceID,
          if (lphWaveOut != NULL)
              *lphWaveOut = HWAVEOUT_16(hWaveOut);
     } else MMSYSTDRV_DeleteThunk(thunk);
+    HeapFree(GetProcessHeap(), 0, wavefmt);
     return ret;
 }
 
@@ -1377,11 +1429,14 @@ UINT16 WINAPI waveOutRestart16(HWAVEOUT16 hWaveOut16)
 UINT16 WINAPI waveOutGetPosition16(HWAVEOUT16 hWaveOut, LPMMTIME16 lpTime,
                                    UINT16 uSize)
 {
+    DWORD	level;
     UINT	ret;
     MMTIME	mmt;
 
     mmt.wType = lpTime->wType;
+    ReleaseThunkLock(&level);
     ret = waveOutGetPosition(HWAVEOUT_32(hWaveOut), &mmt, sizeof(mmt));
+    RestoreThunkLock(level);
     MMSYSTEM_MMTIME32to16(lpTime, &mmt);
     return ret;
 }
diff --git a/dlls/mmsystem.dll16/mmsystem.dll16.spec b/dlls/mmsystem.dll16/mmsystem.dll16.spec
index 1dbd5c02daf..c2d1c88ba5c 100644
--- a/dlls/mmsystem.dll16/mmsystem.dll16.spec
+++ b/dlls/mmsystem.dll16/mmsystem.dll16.spec
@@ -174,3 +174,5 @@
 
 # these are Wine only exported functions. Is there another way to do it ?
 2047   pascal  __wine_mmThreadEntryPoint(long) WINE_mmThreadEntryPoint
+
+@ stdcall -arch=win32 xlate_str_handle(ptr ptr)
-- 
2.39.1

